<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Conceptos Clave: JPA y Hibernate</title>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background-color: #f9f9f9;
      color: #333;
      margin: 0;
      padding: 2rem;
      line-height: 1.6;
    }
    h1, h2, h3 {
      color: #222;
    }
    h1 {
      text-align: center;
      border-bottom: 3px solid #ddd;
      padding-bottom: 0.5rem;
      margin-bottom: 1.5rem;
    }
    section {
      margin-bottom: 2.5rem;
      background-color: #fff;
      padding: 1.5rem;
      border-radius: 10px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.08);
    }
    pre {
      background: #f4f4f4;
      padding: 1rem;
      border-radius: 8px;
      overflow-x: auto;
    }
    code {
      color: #c7254e;
      background-color: #f9f2f4;
      padding: 2px 4px;
      border-radius: 4px;
    }
    ul {
      margin-left: 1.5rem;
    }
  </style>
</head>
<body>

  <h1>Conceptos Fundamentales: JPA y Hibernate</h1>

  <section>
    <h2>1. ¿Qué es JPA?</h2>
    <p>
      <strong>JPA (Java Persistence API)</strong> es una especificación de Java EE (ahora Jakarta EE) que define un estándar para el mapeo 
      objeto-relacional (ORM) entre clases Java y tablas de bases de datos.  
      No es una implementación por sí misma, sino un conjunto de interfaces y anotaciones que otras herramientas (como Hibernate o EclipseLink) implementan.
    </p>

    <h3>Principales características:</h3>
    <ul>
      <li>Permite mapear clases Java a tablas de base de datos usando anotaciones.</li>
      <li>Administra entidades y su ciclo de vida (persistencia, actualización, eliminación).</li>
      <li>Proporciona una API estándar: <code>EntityManager</code>, <code>EntityTransaction</code>, <code>Query</code>, etc.</li>
      <li>Es portable entre distintos proveedores (Hibernate, EclipseLink, OpenJPA).</li>
    </ul>

    <h3>Ejemplo básico con JPA:</h3>
    <pre><code>@Entity
@Table(name = "usuarios")
public class Usuario {

  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Long id;

  private String nombre;
  private String email;

  // Getters y setters
}</code></pre>

    <pre><code>@PersistenceContext
private EntityManager entityManager;

public void guardarUsuario(Usuario usuario) {
  entityManager.persist(usuario);
}</code></pre>
  </section>

  <section>
    <h2>2. ¿Qué es Hibernate?</h2>
    <p>
      <strong>Hibernate</strong> es una de las implementaciones más populares de la especificación JPA.  
      Fue creado antes que JPA y, de hecho, influyó en su diseño. Hibernate ofrece su propio conjunto de APIs además de 
      implementar la especificación estándar.
    </p>

    <h3>Funciones principales:</h3>
    <ul>
      <li>Implementa completamente la especificación JPA.</li>
      <li>Proporciona su propio lenguaje de consultas: <strong>HQL (Hibernate Query Language)</strong>.</li>
      <li>Administra el estado de las entidades a través de su <code>SessionFactory</code> y <code>Session</code>.</li>
      <li>Permite caching en primer y segundo nivel para mejorar el rendimiento.</li>
      <li>Soporta herencia, relaciones bidireccionales, y carga diferida (lazy loading).</li>
    </ul>

    <h3>Ejemplo con Hibernate nativo:</h3>
    <pre><code>Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();

Usuario u = new Usuario();
u.setNombre("Carlos");
u.setEmail("carlos@ejemplo.com");

session.save(u);
tx.commit();
session.close();</code></pre>
  </section>

  <section>
    <h2>3. Diferencias entre JPA y Hibernate</h2>
    <table border="1" cellpadding="8" cellspacing="0" style="border-collapse: collapse; width:100%; text-align:left;">
      <tr><th>Aspecto</th><th>JPA</th><th>Hibernate</th></tr>
      <tr>
        <td>Tipo</td>
        <td>Especificación (interfaz estándar)</td>
        <td>Implementación concreta de JPA</td>
      </tr>
      <tr>
        <td>API principal</td>
        <td><code>EntityManager</code></td>
        <td><code>Session</code></td>
      </tr>
      <tr>
        <td>Lenguaje de consultas</td>
        <td>JPQL (Java Persistence Query Language)</td>
        <td>HQL (Hibernate Query Language)</td>
      </tr>
      <tr>
        <td>Caché</td>
        <td>Depende del proveedor</td>
        <td>Caché de primer y segundo nivel integradas</td>
      </tr>
      <tr>
        <td>Portabilidad</td>
        <td>Alta (funciona con cualquier implementación compatible)</td>
        <td>Menor (al usar extensiones propietarias)</td>
      </tr>
    </table>
  </section>

  <section>
    <h2>4. Funcionamiento Interno de Hibernate</h2>
    <p>
      Hibernate utiliza un <strong>SessionFactory</strong> para crear y administrar sesiones (<code>Session</code>) 
      que manejan el ciclo de vida de las entidades.  
      Estas sesiones mantienen un <em>contexto de persistencia</em> donde las entidades se asocian a su representación en la base de datos.
    </p>

    <h3>Ciclo de vida de una entidad:</h3>
    <ul>
      <li><strong>Transient:</strong> el objeto existe en memoria, pero no en la base de datos.</li>
      <li><strong>Persistent:</strong> el objeto está asociado a una sesión y será sincronizado con la base de datos.</li>
      <li><strong>Detached:</strong> la sesión se cerró y el objeto ya no está sincronizado.</li>
      <li><strong>Removed:</strong> marcado para eliminación.</li>
    </ul>

    <h3>Ejemplo de sincronización automática:</h3>
    <pre><code>Usuario u = session.get(Usuario.class, 1L);
u.setEmail("nuevo@correo.com");
session.getTransaction().commit(); // Hibernate actualiza automáticamente la BD
</code></pre>
  </section>

  <section>
    <h2>5. Relaciones entre Entidades</h2>
    <p>
      Hibernate y JPA soportan relaciones complejas mediante anotaciones.  
      Estas definen cómo se asocian las tablas en la base de datos.
    </p>

    <ul>
      <li><code>@OneToOne</code>: Relación uno a uno.</li>
      <li><code>@OneToMany</code> y <code>@ManyToOne</code>: Relaciones padre-hijo.</li>
      <li><code>@ManyToMany</code>: Asociación entre colecciones.</li>
    </ul>

    <pre><code>@Entity
public class Pedido {
  @Id
  private Long id;

  @ManyToOne
  private Usuario usuario;

  @OneToMany(mappedBy = "pedido", cascade = CascadeType.ALL)
  private List&lt;Producto&gt; productos;
}</code></pre>
  </section>

  <section>
    <h2>6. Transacciones y el Contexto de Persistencia</h2>
    <p>
      Hibernate maneja transacciones a través de <code>Session</code> o de un <code>EntityManager</code> JPA.  
      Dentro de una transacción, las operaciones sobre entidades se reflejan automáticamente en la base de datos al hacer <code>commit()</code>.
    </p>

    <h3>Ejemplo con JPA:</h3>
    <pre><code>@Transactional
public void actualizarUsuario(Long id) {
  Usuario u = entityManager.find(Usuario.class, id);
  u.setNombre("Actualizado");
  // No se necesita entityManager.merge(u);
  // JPA sincroniza automáticamente al finalizar la transacción
}</code></pre>
  </section>

  <section>
    <h2>7. Buenas Prácticas</h2>
    <ul>
      <li>Preferir <strong>Lazy Loading</strong> para relaciones grandes.</li>
      <li>Usar <strong>DTOs</strong> para transferir datos y evitar cargar entidades completas.</li>
      <li>Evitar operaciones dentro de bucles (<code>N+1</code> queries problem).</li>
      <li>Configurar caché de segundo nivel con <strong>Ehcache</strong> o <strong>Hazelcast</strong>.</li>
      <li>Definir correctamente equals() y hashCode() en entidades basadas en el identificador.</li>
    </ul>
  </section>

</body>
</html>
